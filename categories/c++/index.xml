<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>c++ on hyy space</title><link>https://hyy313.github.io/categories/c++/</link><description>Recent content in c++ on hyy space</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 13 Dec 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://hyy313.github.io/categories/c++/index.xml" rel="self" type="application/rss+xml"/><item><title>重新学c++ day13 内存管理 loki advanced allocator</title><link>https://hyy313.github.io/p/%E9%87%8D%E6%96%B0%E5%AD%A6c-day13-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-loki-advanced-allocator/</link><pubDate>Sun, 13 Dec 2020 00:00:00 +0000</pubDate><guid>https://hyy313.github.io/p/%E9%87%8D%E6%96%B0%E5%AD%A6c-day13-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-loki-advanced-allocator/</guid><description>源自侯捷老师内存管理课程！
loki allocator FixedAllocator allocate
分配流程：
寻找哪个块还有空间：
1.1 如果没有空间，需要申请新块;
1.2 有空间，取空间对应chunk。
找到对应的chunk，调用chunk的allocate。
为什么要操作deallocChunk指针？明明分配空间没有影响！
有影响！注意使用的是vector，有可能会有内存移动！！！
为什么要写&amp;amp;*i，&amp;amp;*操作不是可以抵消吗？
因为i是iterator，不是指针pointer！！！
未解决：有空间，可能chunk中的块大小不满足，怎么办？
deallocate
回收流程：
找到对应位置，删除：
1.1 经典方法：根据指针加空间大小判断是否在该区间内； 1.2 不使用遍历，使用逼近检测，由dealloc出发向两头寻找。
执行对应的删除操作，需要判断是否全回收：
2.1 当前是最后一个chunk，如果前一个chunk也为空，回收当前chunk及最后一个；
2.2 当前不是最后一个chunk，并且最后一个chunk也为空，回收最后一个；
2.3 当前不是最后一个chunk，并且不是全回收，将当前chunk置换到vector最后，回收。
未考虑回收不在管理的空间怎么办？
lo hi 同时碰到边界，直接返回不在！
未解决：特殊情况下不归还chunk？
analyz 存在bug：无法回收不是自己申请的空间、特殊情况不回收； 暴力loop，改进逼近loop判断落在那个区间； vector取代list； 不需要cnt就可以简单通过最后一个chunk是否为空判断全回收，同时带了defer； vector调用的什么allocator，由于vector比较简单，可以自己手撸一个。</description></item><item><title>重新学c++ day12 内存管理 loki allocator</title><link>https://hyy313.github.io/p/%E9%87%8D%E6%96%B0%E5%AD%A6c-day12-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-loki-allocator/</link><pubDate>Sat, 12 Dec 2020 00:00:00 +0000</pubDate><guid>https://hyy313.github.io/p/%E9%87%8D%E6%96%B0%E5%AD%A6c-day12-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-loki-allocator/</guid><description>源自侯捷老师内存管理课程！
loki allocator 3 classes
3层结构，由下至上：Chunk、FixedAllocator、SmallObjAllocator
Chunk：最下层具体存储结构，第一个指针直向全体空间，第二个为第一个待分配空间下标index，第三个为已分配空间数量。 FixedAllocator：中间管理层，Chunk数组，两个Chunk指针。 SmallObjAllocator：最高层，FixedChunk数组，两个FixedChunk指针，chunk大小，最大对象大小。 loki alloc
chunk alloc
采用类似embedded pointer思想，将第一个byte用作index，具体分配出去之后可以被覆盖！
分配块流程：根据chunk第二个参数即第一个待分配的空间下标index进行分配，将待分配空间中的第一个位置拿出来替换chunk第二个参数index，可用块数&amp;ndash;。
回收块流程：根据chunk指针与已分配空间块数和每块大小，可以判断指针是否属于该chunk。（穷举遍历：并不消耗过多时间）头插法，将当前块第一个byte改为chunk中第二个index值，将chunk中index值修改为回收块下标，可用块数++。</description></item><item><title>重新学c++ day11 内存管理 vc memory alloc</title><link>https://hyy313.github.io/p/%E9%87%8D%E6%96%B0%E5%AD%A6c-day11-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-vc-memory-alloc/</link><pubDate>Fri, 11 Dec 2020 00:00:00 +0000</pubDate><guid>https://hyy313.github.io/p/%E9%87%8D%E6%96%B0%E5%AD%A6c-day11-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-vc-memory-alloc/</guid><description>源自侯捷老师内存管理课程！
vc6 memory alloc alloc
首次分配初始化流程：
HeapAlloc：堆分配，初始化16个header； VirtualAlloc：对header做内存分配，占据1MB内存； HeapAlloc：初始化header管理的Region和Groups； VirtualAlloc：从1MB中分配32K（8个4K页）。 然后将申请到的32K挂到Group1的最后一个Entry上，同步更新Region的bitmap中的最高位为1，表示最后一个实体上有待分配内存。 分配流程：
从待分配中切割出需要的大小，根据需要大小计算（就是16倍数向上取整，同之前的allocator），再结合位图查找出比其大的第一个待分配块； 块中剩余空间挂载到对应的实体上，计算方式为空间大小/16，修改对应的位图位置为1。 隐藏细节： 正常分配的空间带Debug header，其中前两者为指针，此处的指针同嵌入式指针，尽在为使用的空间存在，使用的空间会被对应内容覆盖。
cntEntries++!
回收流程：将块挂载到对应Entry，计算方式同上，修改对应位图位置为1。
隐藏细节： 为什么直接挂载过去，不用担心有多个吗？因为会有合并操作！见下面合并。
cntEntries&amp;ndash;!
合并流程：
根据指针-4B，回到前cookie位置，加上cookie中的块大小，得到下一块的起始位置，即cookie位置； 查看对应cookie的最后一位，是0，执行向后合并； 再根据指针-4B，回到当前cookie位置，再-4B，得到上一块的尾cookie位置； 查看对应cookie的最后一位，是0，执行向前合并。 cookie的作用： 如同篱笆一样，鲜明的切割出每一块的前后，方便debug检测越界；但是最重要的原因是方便malloc中回收内存、避免内存碎片。
free
释放流程：
根据p的位置可以计算出其属于哪个Header，通过p-header的pHeapData&amp;lt;1B判断； 根据p的位置计算其属于那个Group:（p-pHeapData）/32KB; 根据p计算出其属于哪个Entry（free-list）：p-pHeapData-groupNum*32KB/16B。 得到最终位置，进行释放。</description></item><item><title>重新学c++ day10 内存管理 vc malloc</title><link>https://hyy313.github.io/p/%E9%87%8D%E6%96%B0%E5%AD%A6c-day10-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-vc-malloc/</link><pubDate>Wed, 09 Dec 2020 00:00:00 +0000</pubDate><guid>https://hyy313.github.io/p/%E9%87%8D%E6%96%B0%E5%AD%A6c-day10-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-vc-malloc/</guid><description>源自侯捷老师内存管理课程！
vc malloc vc6与vc10对比
vc6 malloc 分析
heap_init：从系统获取内存页（4k），供后续使用。
heap_init使用的header结构，16个，一个管理1MB空间。
问题： 详细探索其中结构，总共16M？，32与64是管理啥的？
ioinit：初始化块中debug的部分！
ioinit中debug使用的debug header：
CrtMemBlockHeader&amp;ndash;用于Debug的块结构，即为DEBUG header
前向指针 后向指针 文件名 行数 块大小 块使用类型标记，见本章最后一张图 流水号 前无人区 后续结构：
数据块 后无人区 前后无人区用于保护真正的数据块，调试的时候方便检测出使用越界！
上下红色为cookie。
heap alloc：根据申请的空间分配内存。
比1016而不比1024是因为还有8为cookie留的！
sbh alloc block：分配的块结构。
ROUNDUP(块大小+cookie)，向上取到16的倍数！
cookie中的内容借用最后一位的0、1表示该块是否分配！</description></item><item><title>重新学c++ day9 内存管理 GN2.9 std::alloc 3</title><link>https://hyy313.github.io/p/%E9%87%8D%E6%96%B0%E5%AD%A6c-day9-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-gn2.9-stdalloc-3/</link><pubDate>Tue, 08 Dec 2020 00:00:00 +0000</pubDate><guid>https://hyy313.github.io/p/%E9%87%8D%E6%96%B0%E5%AD%A6c-day9-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-gn2.9-stdalloc-3/</guid><description>源自侯捷老师内存管理课程！
std::alloc 代码风格
优秀的避免非语法bug的写法 判断变量是否为某个值的时候，将值写在==左边，变量在右边，就可以避免漏写=！ 变量最好离使用代码近一点，防止中间发生变化！ pointer不跟着定义，属于变量部分&amp;hellip;emm，为了代码可读性，直接分开定义！ 炫技函数指针&amp;hellip;老老实实写代码！ new就要配合free使用。 pool allocator
可以根据结果观察到，std_alloc与pool_allocator使用内存池，减少了分配次数与cookie，但是由于内存池本身结构增加了内存消耗！
std_alloc本质上底层还是使用malloc，只是不像之前一样要一个给一个，而是我一次给你申请20个，减少了19个cookies。 所以侯捷老师说的使用operator new解决不太能理解，因为operator new本质也是调用的malloc。 operator new少掉cookie通过规定malloc一次要多个来解决内部cookie，但是malloc自动去申请的空间总是自带cookie。 此处还需要观察一下！</description></item><item><title>重新学c++ day8 内存管理 GN2.9 std::alloc 2</title><link>https://hyy313.github.io/p/%E9%87%8D%E6%96%B0%E5%AD%A6c-day8-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-gn2.9-stdalloc-2/</link><pubDate>Mon, 07 Dec 2020 00:00:00 +0000</pubDate><guid>https://hyy313.github.io/p/%E9%87%8D%E6%96%B0%E5%AD%A6c-day8-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-gn2.9-stdalloc-2/</guid><description>源自侯捷老师内存管理课程！
GN2.9 std::alloc 源码剖析 一级分配器：用于处理无法使用内存池分配空间的场景。 通过使用handler完成。
二级分配器：使用前一篇中的内存池思想进行分配。 private:
ROUND_UP：向上取16倍数。
FREELIST_INDEX：根据大小去到对应的内存池位置。
refill：申请空间。
chunk_alloc：对未分配空间做分配。
_ALIGN：小区块下界。
_ALIGN：小区块上界。
_NFREELISTS：内存池块类别大小，即free-list个数。
start_free：未分配空间头指针。
end_free：未分配空间尾指针。
heap_size：已申请空间大小。
public:
allocate：申请内存。
deallocate：释放内存。
问题：
释放的空间没有判断是否是内存池的。
因为不是内存池的大小不是固定为8的倍数，会带来灾难后果。
没有free，释放的空间并没有真正退回，而是一直持有。
会有浪费内存的现象！反而不如malloc带cookie？
分配的时候，将得到的块返回，将当前的free-list指针指向第一个空块。
回收的时候，结合上面的思想，将要回收的空间头插回free-list指针。
严格遵循流程：</description></item><item><title>重新学c++ day7 内存管理 GN2.9 std::alloc</title><link>https://hyy313.github.io/p/%E9%87%8D%E6%96%B0%E5%AD%A6c-day7-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-gn2.9-stdalloc/</link><pubDate>Sun, 06 Dec 2020 00:00:00 +0000</pubDate><guid>https://hyy313.github.io/p/%E9%87%8D%E6%96%B0%E5%AD%A6c-day7-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-gn2.9-stdalloc/</guid><description>源自侯捷老师内存管理课程！
GN2.9 std::alloc 运行机制
std::alloc由16个指针组成，共同构成一个内存池。
从0-15的指针分别对应8B-8*16B的基本块大小！
分配流程（无限内存） 申请空间，自动对齐至8字节； 查看对应指针有无空间： 2.1 没有，查看是否有申请空间未使用：
2.1.1 若有，检查未使用空间是否足够分配： 2.1.1.1 空间可以进行分配，则尽最大可能分配，分配规则为1-20个对应块大小； 2.1.1.2 空间不足，则将当前空间分配给合适的指针块，再去做空间申请。 2.1.2 若没有，则申请空间。申请规则：申请20个该块大小，同时再申请一份20个块大小做占备池，还要申请已申请空间除16对齐至16倍数的追加量。 2.2 有，则检查是否有剩余块：
2.2.1 有，直接分配； 2.</description></item><item><title>重新学c++ day6 内存管理 handler and std::allocator初涉</title><link>https://hyy313.github.io/p/%E9%87%8D%E6%96%B0%E5%AD%A6c-day6-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-handler-and-stdallocator%E5%88%9D%E6%B6%89/</link><pubDate>Sat, 05 Dec 2020 00:00:00 +0000</pubDate><guid>https://hyy313.github.io/p/%E9%87%8D%E6%96%B0%E5%AD%A6c-day6-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-handler-and-stdallocator%E5%88%9D%E6%B6%89/</guid><description>源自侯捷老师内存管理课程！
handler
handler的作用就是在operator new分配空间失败的时候，解决问题的手段，会被循环调用，最后才会抛出std::bad_alloc异常。
handler常用手段：
调整内存，重新分配内存空间 打印错误，做错误处理，调用abort()或exit() 空handler会带来死循环，直至分配到内存为止！
default &amp;amp; delete
并不只有默认构造函数、默认拷贝构造函数可以=default和=delete; operator new/delete也可以。
实际测试发现，并不能=default，但可以=delete。
allocator vc6 malloc() allocator抽象出来就是为了减少malloc的cookie消耗，同时有一个先决假设：malloc效率低（实际并不是）。
前后红色的为cookie，中间为debug模块、pad填充模块和实际区块，共同组成16倍数的空间。 malloc在真正的区块周围进行封装都是为了方便free释放空间与其余一些操作，比如debug？
vc6 std::allocator
观察代码可以发现，vc6的标准allocator使用的还是operator new/delete()。
BC5 std::allocator
观察代码可以发现，BC5的标准allocator使用的也是operator new/delete()。
GN2.9 std::allocator
观察代码可以发现，GN2.9的标准allocator使用的也是operator new/delete()。 但是有个注释，不建议使用标准的allocator，建议使用GN2.9带来的SGI allocator。
然而GN2.9的容器使用的不是标准的allocator，而是SGI allocator。
此处还有一点不同，分配空间时的方法用的是static的，而不是对象的方法调用。 alloc::allocate(512)对比前面的allocator&amp;lt;int&amp;gt;().allocate(512)。
GN4.9 std::allocator</description></item><item><title>重新学c++ day5 内存管理 allocator演变</title><link>https://hyy313.github.io/p/%E9%87%8D%E6%96%B0%E5%AD%A6c-day5-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-allocator%E6%BC%94%E5%8F%98/</link><pubDate>Fri, 04 Dec 2020 00:00:00 +0000</pubDate><guid>https://hyy313.github.io/p/%E9%87%8D%E6%96%B0%E5%AD%A6c-day5-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-allocator%E6%BC%94%E5%8F%98/</guid><description>源自侯捷老师内存管理课程！
allocator 人类追求的本质是简化操作，在追求懒得路上一路狂奔，这就是代码重用的意义。(●'◡'●)
static allocator 观察前面的class allocator发现，内存分配操作相同，可以抽取出来实现代码重用。
macro allocator 观察static allocator发现，class内部对于其使用也是重复过程，可以进一步抽取代码实现复用。
global allocator 直接开辟一个固定大小的allocator专门来做内存分配，内存池思想，std::allocator雏形。</description></item><item><title>重新学c++ day4 内存管理 class allocator</title><link>https://hyy313.github.io/p/%E9%87%8D%E6%96%B0%E5%AD%A6c-day4-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-class-allocator/</link><pubDate>Thu, 03 Dec 2020 00:00:00 +0000</pubDate><guid>https://hyy313.github.io/p/%E9%87%8D%E6%96%B0%E5%AD%A6c-day4-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-class-allocator/</guid><description>源自侯捷老师内存管理课程！
class allocator pre-class allocator 1
这里的内存分配，与重载new()不同之处在于引入了一个next指针以构建类似内存池的思想，提前把后续需要的申请出来组成一个链表（观察代码可以发现其本质就是一个数组）。但是代价是每个对象增加了一个指针的空间消耗，以及不确定后续是否会全部使用造成的空间浪费。
这里我学习的时候走入了一个误区，定义类指针数组的时候去申请了空间，后面对类初始化的时候又去申请了空间。最开始我认为这里有矛盾，对一个类做了两次空间申请，所以就很好奇，此处类初始化的new难道不就是placement new吗？
其实并不是如此，还是基础知识不牢靠，上面的猜想是定义类数组！
定义指针数组的本质是定义了一个指向该类型的指针的集合，所以定义数组的时候申请的空间是一个指针数组，做类初始化的时候才真正调用new申请类的空间同时进行类的初始化。
验证如下：
#include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; class Test { public: Test() { cout &amp;lt;&amp;lt; &amp;#34;Test()&amp;#34; &amp;lt;&amp;lt; endl; } void *operator new(size_t size) { cout &amp;lt;&amp;lt; &amp;#34;new&amp;#34; &amp;lt;&amp;lt; endl; ::operator new(size); } string s = &amp;#34;string&amp;#34;; }; int main() { Test *at[10]; cout &amp;lt;&amp;lt; &amp;#34;string size :&amp;#34; &amp;lt;&amp;lt; sizeof(string) &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;at size : &amp;#34; &amp;lt;&amp;lt; sizeof(at) &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;at[0] size : &amp;#34; &amp;lt;&amp;lt; sizeof(at[0]) &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; at[9]-&amp;gt;s &amp;lt;&amp;lt; endl; at[0] = new Test(); return 0; } 运行结果：</description></item><item><title>重新学c++ day3 内存管理 overload</title><link>https://hyy313.github.io/p/%E9%87%8D%E6%96%B0%E5%AD%A6c-day3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-overload/</link><pubDate>Wed, 02 Dec 2020 00:00:00 +0000</pubDate><guid>https://hyy313.github.io/p/%E9%87%8D%E6%96%B0%E5%AD%A6c-day3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-overload/</guid><description>源自侯捷老师内存管理课程！
重载 由于之前提到的默认的c++ primitives在申请空间时需要额外的cookies，所以我们往往希望使用自己重载的版本。
重载::operator new()、::operator delete() ::operator new()和::operator delete()都是全局(真正的全局，不是局限于单个文件的全局)函数，不可以定义在某个namespace内。
重载后影响较大，因为会影响所有默认的new()、delete()，所以要十分注意。
重载operator new()、operator delete()
重载operator new[]、operator delete[]
重载placement new/delete即new()、delete() 正常来说对于placement new是不需要匹配的placement delete的，因为一般其没有空间分配操作。 但是我们重载的版本变为new()，先申请空间然后调用类constuctor做对象初始化，一但空间分配失败，需要对应的delete()，但是可以忽略（在vc6中会有警告提示）。
定义的placement delete或者确切的说delete()只有在new调用的constructor函数失败时才会被调用，至于具体会不会调用还要看编译器的处理。 猜测有的版本不调用是因为默认写法的空间分配是会做是否能成功申请到空间的判断的，若不能就直接释放，故不需要调用。
注 placement_new第一个参数必须是size_t类型。
basic_string 重载的 new(extra)</description></item><item><title>重新学c++ day2 内存管理 c++ primitives</title><link>https://hyy313.github.io/p/%E9%87%8D%E6%96%B0%E5%AD%A6c-day2-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-c-primitives/</link><pubDate>Tue, 01 Dec 2020 00:00:00 +0000</pubDate><guid>https://hyy313.github.io/p/%E9%87%8D%E6%96%B0%E5%AD%A6c-day2-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-c-primitives/</guid><description>源自侯捷老师内存管理课程！
c++程序，使用memory的途径
c++程序有四种方式使用内存：
c++ libarary（比如标准库）； c++ primitives（new,new[],new(),::operator new(),&amp;hellip;）； CRT malloc/free； OS API。
new expression
new expression具体执行流程：
首先调用operator new()，申请空间 申请空间，再去调用malloc分配内存 对申请的内存进行转换，以便初始化 通过placement new()进行初始化 注：
placement new()用于对已有空间进行初始化，而不申请空间，故没有配对的placement delete
delete expression流程：
首先调用析构函数 接着operator delete 再调用free释放内存 array new, array delete
此处不太寻常，进行new[]时，申请的空间带一块cookie。
new[]与delete[]应配对使用。若使用delete，由于底层调用的free，根据cookie可以正确释放new申请内存空间，但是无法释放构造函数中申请的别的内存空间。
让我们看看cookie，也就是new[]到底申请了一片什么空间？
对于内置基本类型，如下：
注意到申请的空间并不止40bytes！
再来看对于自定义类会怎样：</description></item><item><title>重新学c++ day1 c++ 类大小和默认函数</title><link>https://hyy313.github.io/p/%E9%87%8D%E6%96%B0%E5%AD%A6c-day1-c-%E7%B1%BB%E5%A4%A7%E5%B0%8F%E5%92%8C%E9%BB%98%E8%AE%A4%E5%87%BD%E6%95%B0/</link><pubDate>Mon, 30 Nov 2020 00:00:00 +0000</pubDate><guid>https://hyy313.github.io/p/%E9%87%8D%E6%96%B0%E5%AD%A6c-day1-c-%E7%B1%BB%E5%A4%A7%E5%B0%8F%E5%92%8C%E9%BB%98%E8%AE%A4%E5%87%BD%E6%95%B0/</guid><description>源自快手面试，痛定思痛，决定重新深入学习一遍c++！
size of class 空类大小 带一个函数的类大小 继承2的类的大小 虚继承2的类的大小 带一个虚函数的类的大小 继承5的空类大小 虚继承5的空类大小 #include &amp;lt;iostream&amp;gt; class C1 { }; class C2 { public: void func() {} }; class C3 : C2 { }; class C4 : virtual C2 { }; class C5 { public: virtual void vfunc() {} }; class C6 : C5 { }; class C7 : virtual C5 { }; int main() { std::cout &amp;lt;&amp;lt; &amp;#34;C1(empty class) size = &amp;#34; &amp;lt;&amp;lt; sizeof(C1) &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; &amp;#34;C2(have a function) size = &amp;#34; &amp;lt;&amp;lt; sizeof(C2) &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; &amp;#34;C3(extend C2) size = &amp;#34; &amp;lt;&amp;lt; sizeof(C3) &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; &amp;#34;C4(virtual extend C2) size = &amp;#34; &amp;lt;&amp;lt; sizeof(C4) &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; &amp;#34;C5(have a virtual function) size = &amp;#34; &amp;lt;&amp;lt; sizeof(C5) &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; &amp;#34;C6(extend C5) size = &amp;#34; &amp;lt;&amp;lt; sizeof(C6) &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; &amp;#34;C7(virtual extend C5) size = &amp;#34; &amp;lt;&amp;lt; sizeof(C7) &amp;lt;&amp;lt; std::endl; } 运行结果</description></item></channel></rss>