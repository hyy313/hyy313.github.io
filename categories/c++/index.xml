<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>c++ on hyy space</title><link>https://hyy313.github.io/categories/c++/</link><description>Recent content in c++ on hyy space</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 03 Dec 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://hyy313.github.io/categories/c++/index.xml" rel="self" type="application/rss+xml"/><item><title>重新学c++ day3 内存管理 class allocator</title><link>https://hyy313.github.io/p/%E9%87%8D%E6%96%B0%E5%AD%A6c-day3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-class-allocator/</link><pubDate>Thu, 03 Dec 2020 00:00:00 +0000</pubDate><guid>https://hyy313.github.io/p/%E9%87%8D%E6%96%B0%E5%AD%A6c-day3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-class-allocator/</guid><description>源自侯捷老师内存管理课程！
class allocator pre-class allocator 1
这里的内存分配，与重载new()不同之处在于引入了一个next指针以构建类似内存池的思想，提前把后续需要的申请出来组成一个链表（观察代码可以发现其本质就是一个数组）。但是代价是每个对象增加了一个指针的空间消耗，以及不确定后续是否会全部使用造成的空间浪费。
这里我学习的时候走入了一个误区，定义类数组的时候去申请了空间，后面对类初始化的时候又去申请了空间。最开始我认为这里有矛盾，对一个类做了两次空间申请，所以就很好奇，此处类初始化的new难道不就是placement new吗？
其实并不是如此，还是基础知识不牢靠！定义数组的本质是定义了一个指向该类型的指针的集合，所以定义数组的时候申请的空间是一个指针数组，做类初始化的时候才真正调用new申请类的空间同时进行类的初始化。
验证如下：
#include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; class Test { public: Test() { cout &amp;lt;&amp;lt; &amp;#34;Test()&amp;#34; &amp;lt;&amp;lt; endl; } void *operator new(size_t size) { cout &amp;lt;&amp;lt; &amp;#34;new&amp;#34; &amp;lt;&amp;lt; endl; ::operator new(size); } string s = &amp;#34;string&amp;#34;; }; int main() { Test *at[10]; cout &amp;lt;&amp;lt; &amp;#34;string size :&amp;#34; &amp;lt;&amp;lt; sizeof(string) &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;at size : &amp;#34; &amp;lt;&amp;lt; sizeof(at) &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;at[0] size : &amp;#34; &amp;lt;&amp;lt; sizeof(at[0]) &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; at[9]-&amp;gt;s &amp;lt;&amp;lt; endl; at[0] = new Test(); return 0; } 运行结果：</description></item><item><title>重新学c++ day3 内存管理 overload</title><link>https://hyy313.github.io/p/%E9%87%8D%E6%96%B0%E5%AD%A6c-day3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-overload/</link><pubDate>Wed, 02 Dec 2020 00:00:00 +0000</pubDate><guid>https://hyy313.github.io/p/%E9%87%8D%E6%96%B0%E5%AD%A6c-day3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-overload/</guid><description>源自侯捷老师内存管理课程！
重载 由于之前提到的默认的c++ primitives在申请空间时需要额外的cookies，所以我们往往希望使用自己重载的版本。
重载::operator new()、::operator delete() ::operator new()和::operator delete()都是全局(真正的全局，不是局限于单个文件的全局)函数，不可以定义在某个namespace内。
重载后影响较大，因为会影响所有默认的new()、delete()，所以要十分注意。
重载operator new()、operator delete()
重载operator new[]、operator delete[]
重载placement new/delete即new()、delete() 正常来说对于placement new是不需要匹配的placement delete的，因为一般其没有空间分配操作。 但是我们重载的版本变为new()，先申请空间然后调用类constuctor做对象初始化，一但空间分配失败，需要对应的delete()，但是可以忽略（在vc6中会有警告提示）。
定义的placement delete或者确切的说delete()只有在new调用的constructor函数失败时才会被调用，至于具体会不会调用还要看编译器的处理。 猜测有的版本不调用是因为默认写法的空间分配是会做是否能成功申请到空间的判断的，若不能就直接释放，故不需要调用。
注 placement_new第一个参数必须是size_t类型。
basic_string 重载的 new(extra)</description></item><item><title>重新学c++ day2 内存管理 c++ primitives</title><link>https://hyy313.github.io/p/%E9%87%8D%E6%96%B0%E5%AD%A6c-day2-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-c-primitives/</link><pubDate>Tue, 01 Dec 2020 00:00:00 +0000</pubDate><guid>https://hyy313.github.io/p/%E9%87%8D%E6%96%B0%E5%AD%A6c-day2-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-c-primitives/</guid><description>源自侯捷老师内存管理课程！
c++程序，使用memory的途径
c++程序有四种方式使用内存：
c++ libarary（比如标准库）； c++ primitives（new,new[],new(),::operator new(),&amp;hellip;）； CRT malloc/free； OS API。
new expression
new expression具体执行流程：
首先调用operator new()，申请空间 申请空间，再去调用malloc分配内存 对申请的内存进行转换，以便初始化 通过placement new()进行初始化 注：
placement new()用于对已有空间进行初始化，而不申请空间，故没有配对的placement delete
delete expression流程：
首先调用析构函数 接着operator delete 再调用free释放内存 array new, array delete
此处不太寻常，进行new[]时，申请的空间带一块cookie。
new[]与delete[]应配对使用。若使用delete，由于底层调用的free，根据cookie可以正确释放new申请内存空间，但是无法释放构造函数中申请的别的内存空间。
让我们看看cookie，也就是new[]到底申请了一片什么空间？
对于内置基本类型，如下：
注意到申请的空间并不止40bytes！
再来看对于自定义类会怎样：</description></item><item><title>重新学c++ day1 c++ 类大小和默认函数</title><link>https://hyy313.github.io/p/%E9%87%8D%E6%96%B0%E5%AD%A6c-day1-c-%E7%B1%BB%E5%A4%A7%E5%B0%8F%E5%92%8C%E9%BB%98%E8%AE%A4%E5%87%BD%E6%95%B0/</link><pubDate>Mon, 30 Nov 2020 00:00:00 +0000</pubDate><guid>https://hyy313.github.io/p/%E9%87%8D%E6%96%B0%E5%AD%A6c-day1-c-%E7%B1%BB%E5%A4%A7%E5%B0%8F%E5%92%8C%E9%BB%98%E8%AE%A4%E5%87%BD%E6%95%B0/</guid><description>源自快手面试，痛定思痛，决定重新深入学习一遍c++！
size of class 空类大小 带一个函数的类大小 继承2的类的大小 虚继承2的类的大小 带一个虚函数的类的大小 继承5的空类大小 虚继承5的空类大小 #include &amp;lt;iostream&amp;gt; class C1 { }; class C2 { public: void func() {} }; class C3 : C2 { }; class C4 : virtual C2 { }; class C5 { public: virtual void vfunc() {} }; class C6 : C5 { }; class C7 : virtual C5 { }; int main() { std::cout &amp;lt;&amp;lt; &amp;#34;C1(empty class) size = &amp;#34; &amp;lt;&amp;lt; sizeof(C1) &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; &amp;#34;C2(have a function) size = &amp;#34; &amp;lt;&amp;lt; sizeof(C2) &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; &amp;#34;C3(extend C2) size = &amp;#34; &amp;lt;&amp;lt; sizeof(C3) &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; &amp;#34;C4(virtual extend C2) size = &amp;#34; &amp;lt;&amp;lt; sizeof(C4) &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; &amp;#34;C5(have a virtual function) size = &amp;#34; &amp;lt;&amp;lt; sizeof(C5) &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; &amp;#34;C6(extend C5) size = &amp;#34; &amp;lt;&amp;lt; sizeof(C6) &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; &amp;#34;C7(virtual extend C5) size = &amp;#34; &amp;lt;&amp;lt; sizeof(C7) &amp;lt;&amp;lt; std::endl; } 运行结果</description></item></channel></rss>